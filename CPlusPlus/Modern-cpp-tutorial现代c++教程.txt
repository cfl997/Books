
2023 01 29

11 nullptr   NULL 0   
11 constexpr 编译器能够在编译时就把这些表达式直接优化并植入到程序运行时
     14 内存使用局部变量

2023 01 30
17 if switch 中 临时变量

11 初始化列表 

11 std::tuple std::tie 

17 结构化绑定
	std::tuple <int ,double,std::string>f(){
		return std::make_tuple(1,2.3,"123");
	}
	auto [x,y,z]=f();
	std::cout<<x<<y<<z<<std::endl;

11 auto decltype（表达式）   std::is_same<decltype(x),int>::value
20 auto 函数传参    不能用于推导数组类型

11 尾返回类型 auto 
	template<typename T, typename U>
	auto add2(T x, U y) -> decltype(x+y){
		return x + y;
	}
14  template<typename T, typename U>
	auto add3(T x, U y){
		return x + y;
	}

14 decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，
   它使我们无需显式的指定 decltype 的参数表达式
	decltype(auto) look_up_a_string_1() {
		return lookup1();
	}

17 constexpr 这个关键字引入到 if 语句中  让代码在编译时就完成分支判断

	if constexpr (std::is_integral<T>::value) {
		return t + 1;
	} else {
		return t + 0.001;
	}

11 for (auto data : vec)  区间for迭代

11 using name = oldname       typedef 原名称 新名称

2023 01 31

11 变长参数模板 template<typename... Ts> class Magic; 
允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定

函数参数  也使用同样的表示法代表不定长参数
template<typename... Args> void printf(const std::string &str, Args... args);

解包
    
1.递归模板函数
不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的
#include <iostream>
template<typename T0>
void printf1(T0 value) {
	std::cout << value << std::endl;
}
template<typename T, typename... Ts>
void printf1(T value, Ts... args) {
	std::cout << value << std::endl;
	printf1(args...);
}
int main() {
	printf1(1, 2, "123", 1.1);
	return 0;
}

2.变参模板展开
17
template<typename T0, typename... T>
void printf2(T0 t0, T... t) {
	std::cout << t0 << std::endl;
	if constexpr (sizeof...(t) > 0) printf2(t...);
}

3.初始化列表展开
template<typename T, typename... Ts>
auto printf3(T value, Ts... args) {
	std::cout << value << std::endl;
	(void) std::initializer_list<T>{([&args] {
		std::cout << args << std::endl;
	}(), value)...};
}

17 折叠表达式 
#include <iostream>
template<typename ... T>
auto sum(T ... t) {
	return (t + ...);
}
int main() {
	std::cout << sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) << std::endl;
}
