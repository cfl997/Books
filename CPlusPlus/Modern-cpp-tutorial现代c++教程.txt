
2023 01 29

11 nullptr   NULL 0   
11 constexpr 编译器能够在编译时就把这些表达式直接优化并植入到程序运行时
     14 内存使用局部变量

2023 01 30
17 if switch 中 临时变量

11 初始化列表 

11 std::tuple std::tie 

17 结构化绑定
	std::tuple <int ,double,std::string>f(){
		return std::make_tuple(1,2.3,"123");
	}
	auto [x,y,z]=f();
	std::cout<<x<<y<<z<<std::endl;

11 auto decltype（表达式）   std::is_same<decltype(x),int>::value
20 auto 函数传参    不能用于推导数组类型

11 尾返回类型 auto 
	template<typename T, typename U>
	auto add2(T x, U y) -> decltype(x+y){
		return x + y;
	}
14  template<typename T, typename U>
	auto add3(T x, U y){
		return x + y;
	}

14 decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，
   它使我们无需显式的指定 decltype 的参数表达式
	decltype(auto) look_up_a_string_1() {
		return lookup1();
	}

17 constexpr 这个关键字引入到 if 语句中  让代码在编译时就完成分支判断

	if constexpr (std::is_integral<T>::value) {
		return t + 1;
	} else {
		return t + 0.001;
	}

11 for (auto data : vec)  区间for迭代

11 using name = oldname       typedef 原名称 新名称

2023 01 31

11 变长参数模板 template<typename... Ts> class Magic; 
允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定

函数参数  也使用同样的表示法代表不定长参数
template<typename... Args> void printf(const std::string &str, Args... args);

解包
    
1.递归模板函数
不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的
#include <iostream>
template<typename T0>
void printf1(T0 value) {
	std::cout << value << std::endl;
}
template<typename T, typename... Ts>
void printf1(T value, Ts... args) {
	std::cout << value << std::endl;
	printf1(args...);
}
int main() {
	printf1(1, 2, "123", 1.1);
	return 0;
}

2.变参模板展开
17
template<typename T0, typename... T>
void printf2(T0 t0, T... t) {
	std::cout << t0 << std::endl;
	if constexpr (sizeof...(t) > 0) printf2(t...);
}

3.初始化列表展开
template<typename T, typename... Ts>
auto printf3(T value, Ts... args) {
	std::cout << value << std::endl;
	(void) std::initializer_list<T>{([&args] {
		std::cout << args << std::endl;
	}(), value)...};
}

17 折叠表达式 
#include <iostream>
template<typename ... T>
auto sum(T ... t) {
	return (t + ...);
}
int main() {
	std::cout << sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) << std::endl;
}


2023 02 01

11 非模板类型推导
template <typename T, int BufSize>
class buffer_t {
public:
	T& alloc();
	void free(T& item);
private:
	T data[BufSize];
}

buffer_t<int, 100> buf; // 100 作为模板参数

17 auto 作为非模板类型推导
template <auto value> void foo() {
	std::cout << value << std::endl;
	return;
}
int main() {
	foo<10>(); // value 被推导为 int 类型
}


11 委托构造 构造函数可以在同一个类中一个构造函数调用另一个构造函数
#include <iostream>
class Base {
public:
		int value1;
	int value2;
	Base() {
		value1 = 1;
	}
	Base(int value) : Base() { // 委托 Base() 构造函数
		value2 = value;
	}
};

11 继承构造
class Subclass : public Base {
	public:
		using Base::Base; // 继承构造
};

11 显示虚函数重载  override final
override 关键字将显式的告知编译器进行重载，
编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译
final 则是为了防止类被继续继承以及终止虚函数继续重载引入的

11 显示禁用默认函数
class Magic {
	public:
		Magic() = default; // 显式声明使用编译器生成的构造
		Magic& operator=(const Magic&) = delete; // 显式声明拒绝编译器生成构造
		Magic(int magic_number);
}

11 强类型枚举  enum class
enum class new_enum : unsigned int {
	value1,
	value2,
	value3 = 100,
	value4 = 100
};
不能够被隐式的转换为整数，同时也不能够将其与整数数
字进行比较，更不可能对不同的枚举类型的枚举值进行比较。
但相同枚举值之间如果指定的值相同，那么可以进行比较：
if (new_enum::value3 == new_enum::value4) {
	// 会输出
	std::cout << "new_enum::value3 == new_enum::value4" << std::endl;
}

显示的进行类型转换->获得枚举值
#include <iostream>
template<typename T>
std::ostream& operator<<(
	typename std::enable_if<std::is_enum<T>::value,
		std::ostream>::type& stream, const T& e)
	{
		return stream << static_cast<typename std::underlying_type<T>::type>(e);
	}


11 Lambda表达式

[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {
// 函数体
}

值捕获=  引用捕获&  隐式捕获[] 
表达式捕获 （捕获右值）
#include <iostream>
#include <memory> // std::make_unique
#include <utility> // std::move
void lambda_expression_capture() {
	auto important = std::make_unique<int>(1);
	auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int {
		return x+y+v1+(*v2);
	};
	std::cout << add(3,4) << std::endl;
}
在上面的代码中， important 是一个独占指针，是不能够被 “=” 值捕获到，这时候我们可以将其转
移为右值，在表达式中初始化。


14 泛型Lambda  auto
auto add = [](auto x, auto y) {
	return x+y;
};
add(1, 2);
add(1.1, 2.2);


