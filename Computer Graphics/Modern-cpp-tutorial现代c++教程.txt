
2023 01 29

11 nullptr   NULL 0   
11 constexpr 编译器能够在编译时就把这些表达式直接优化并植入到程序运行时
     14 内存使用局部变量

2023 01 30
17 if switch 中 临时变量

11 初始化列表 

11 std::tuple std::tie 

17 结构化绑定
	std::tuple <int ,double,std::string>f(){
		return std::make_tuple(1,2.3,"123");
	}
	auto [x,y,z]=f();
	std::cout<<x<<y<<z<<std::endl;

11 auto decltype（表达式）   std::is_same<decltype(x),int>::value
20 auto 函数传参    不能用于推导数组类型

11 尾返回类型 auto 
	template<typename T, typename U>
	auto add2(T x, U y) -> decltype(x+y){
		return x + y;
	}
14  template<typename T, typename U>
	auto add3(T x, U y){
		return x + y;
	}

14 decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，
   它使我们无需显式的指定 decltype 的参数表达式
	decltype(auto) look_up_a_string_1() {
		return lookup1();
	}

17 constexpr 这个关键字引入到 if 语句中  让代码在编译时就完成分支判断

	if constexpr (std::is_integral<T>::value) {
		return t + 1;
	} else {
		return t + 0.001;
	}

11 for (auto data : vec)  区间for迭代

11 using name = oldname       typedef 原名称 新名称


